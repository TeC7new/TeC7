\chapter{{\tac}のアーキテクチャ}

{\tec}のアーキテクチャは「TeC教科書」\footnote{
\url{https://github.com/tctsigemura/TecTextBook/raw/master/tec.pdf}}
で詳しく説明されているので，
ここでは{\tac}のアーキテクチャについて簡単に説明する．

%-----------------------------------------
\section{CPUの概要}
{\tac}で使用できるデータの形式，
アドレス空間，
実行モード，
CPU内部のレジスタ構成，
機械語命令，割込みと例外について説明する．

\subsection{データ形式}
\figref{tacData}の「データ形式」に{\tac}が扱うことができるデータを示す．
16ビットの整数データと，16ビットのアドレスデータの他に，
8ビットの整数データを扱うことができる．
16ビットのデータはCPUの内部でもメモリやI/Oでも使用できる．
8ビットデータはメモリ上の配列に格納することだけを想定している．

\subsection{アドレス空間}
\figref{tacData}の「メモリ空間」，「I/O空間」に
{\tac}のメモリとI/Oのアドレス空間を示す．
メモリ空間もI/O空間もバイト単位でアドレスが割り付けてある．
しかし，I/O空間をバイト単位でアクセスする機械語命令を現在のTaCは備えていない
\footnote{以前のTaCはI/O空間もバイト単位でアクセスできたので，
バイト単位でアドレスが割り付けられている．}．
メモリやI/Oの16ビットデータにアクセスする場合は偶数番地を用いる．
8ビットデータはメモリの読み書きだけに使用できる．
メモリの8ビットデータにアクセスする場合は，
CPUレジスタの下位8ビットだけが使用される．

\subsection{実行モード}
{\tac}は「特権モード」，「ユーザモード」，「I/O特権モード」の
三つの実行モードを持っている．

\begin{description}
\item[特権モード]
全ての機械語命令が実行できるモードである．
OSカーネルは特権モードで実行される．
\item[ユーザモード]
実行モードを変更したり，
ハードウェアの状態を変更したりする\emph{特権命令}を実行することができない．
通常，ユーザプログラムはユーザモードで実行される．
\item[I/O特権モード]
IN，OUT機械語命令が実行できるユーザモードである．
入出力ポートに接続したオプションのハードウェア\footnote{
このようなハードウェアはOSによってサポート・管理されない．
}を使用するプリケーションを実行するために用意されている．
\end{description}

\subsection{CPUレジスタとPSW}
\figref{tacData}の「レジスタ構成」にCPU内部のレジスタなどを示す．
レジスタはどれも16ビット幅である．

\subsubsection{CPUレジスタ}
CPUレジスタは，
汎用のG0（General register 0）からG11，
フレームポインタとして使用するFP（Frame Pointer），
特権モード用のスタックポインタSSP（System Stack Pointer），
ユーザモード（I/O特権モードも含む）用の
スタックポインタUSP（User Stack Pointer）からなる．
これらは全て計算用にもアドレス用にも使用できる．
FP，SSP，USPは，以下に説明する特別な意味も持っている．

\subsubsection{フレームポインタ（Frame Pointer）}
フレームポインタ（FP）はCPUレジスタの一つである．
フレームポインタ相対アドレッシングモードで使用できる．
このアドレッシングモードを用いると，
スタックフレーム内のローカル変数や関数引数へ，
1ワード（2バイト）の機械語命令でアクセスできる．

\subsubsection{スタックポインタ（Stack Pointer）}
スタックポインタ（SP）もCPUレジスタの一つである．
{\tac}は特権モード用（SSP），
ユーザモード（I/O特権モード含む）用（USP）の
二本のスタックポインタを持っている．
SSPは特権モードでSPの位置にマップされ，
OSカーネル用のスタックポインタとして使用される．
USPはユーザモード（I/O特権モード含む）でSPの位置にマップされ，
ユーザプログラムのスタックポインタとして使用される．
USPはG14として常時マップされており，
特権モードでもUSPをアクセスすることができる．

\subsubsection{PSW（Program Status Word）}
PSWはPC（Program Counter）とFLAGからなる．
FLAGには，計算結果で変化する
\texttt{V（oVerflow）}，
\texttt{C（Carry）}，
\texttt{S（Sign）}，
\texttt{Z（Zero）}と，
割込み許可\texttt{E（Enable interrupt）}，
特権モード\texttt{P（Privilege）}，
I/O特権モード\texttt{I（I/O Privilege）}，
ユーザ定義\texttt{U（User defined）}の各ビットがある．

FLAGはG15として普通の機械語命令で扱うことも可能であるが，
ユーザモードでは\texttt{E}，\texttt{P}，\texttt{I}の各ビットは変化しない．

\subsection{機械語命令}
\figref{tacInst}に{\tac}の機械語命令の一覧表を示す．
HALTは特権モードでしか使用できない\emph{特権命令}である．
IN，OUTは特権モードとI/O特権モードで使用できる命令である．
これらの命令を非特権モードで実行すると「特権違反例外」が発生する．
SVC命令はシステムコールを発行するために「SVC例外」を発生する．

ほとんどの転送命令と計算命令で8種類のアドレッシング・モードが使用できる．
Direct，Indexed，Immediateの
三つのアドレッシング・モードを使用する場合は2ワードの機械語命令になる．
他のアドレッシング・モードの場合は1ワード命令である．

Byte Register Indirect アドレッシング・モードだけが，
メモリの8ビットデータをアクセスする．
Byte Register Indirect アドレッシング・モードの
ST命令は，CPUレジスタの下位8ビットをメモリに書き込む．
これら以外の命令は，メモリから読み出した8ビットデータの上位に
\|00h|を付加した16ビットデータを使用する．

\subsection{割込み（Interrupt）と例外（Exception）}
{\tac}はベクタ方式（ベクタは\|FFE0h|番地〜）の割込み・例外機構を備えている．
割込み・例外の種類は\tabref{inter}に示す16種類である．
ゼロ除算や特権違反のような
ソフトウェアに起因する割込みを「例外（Exception）」と呼ぶ．
「TLBミス」から「SVC」までの6種類が「例外」 それ以外が「割込み」である．
「割込み」の許可と禁止はFLAGの\texttt{E}ビットを操作することで行う．
「例外」の発生は禁止できない．

割込み（例外）が発生すると次の順で割込み（例外）処理が行われる．
\begin{enumerate}
\item CPU内部の一時レジスタに\emph{FLAGのコピー}が作られる．
\item FLAGが変更され，
割込みが禁止（\texttt{E=0}）の特権モード（\texttt{P=1}）になる．
\item PCと\emph{FLAGのコピー}が順にカーネルスタックにPUSHされる．
\item PCに割込み（例外）ハンドラの開始番地がロードされ，
ハンドラの実行が開始される．
\end{enumerate}

\begin{mytable}{btp}{割込み・例外の種類と意味}{inter}
  \begin{tabular}{ r  l | l }\hline\hline
    \multicolumn{2}{c}{割込み・例外} &
    \multicolumn{1}{|c}{意　味} \\\hline
    0 & Timer0      & ハードウェアタイマー0に設定された時刻になった．\\
    1 & Timer1      & ハードウェアタイマー1に設定された時刻になった．\\
    2 & RN4020受信  & Bluetoothモジュールから1バイトのデータを受信した．\\
    3 & RN4020送信  & Bluetoothモジュールへ1バイトのデータを送信し終えた． \\
    4 & FT232RL受信 & USBシリアル変換ICから1バイトのデータを受信した．\\
    5 & FT232RL送信 & USBシリアル変換ICへ1バイトのデータを送信し終えた． \\
    6 & TeC受信     & TeCから1バイトのデータを受信した． \\
    6 & TeC送信     & TeCへ1バイトのデータを送信し終えた． \\
    8 & マイクロSD  & マイクロSDのホストコントローラが
                      コマンドを実行し終えた．\\
    9 & PIO         & 入出力ポートの監視中のビットに変化があった． \\
    10& TLB ミス    & MMU有効時にTLBに必要なエントリが見つからない． \\
    11& メモリ保護違反 & 奇数アドレスでワードデータをアクセスした．または，\\
      &                & ページの保護モード（RWX）に
                         一致しないアクセスがされた． \\
    12& ゼロ除算    & 割り算機械語命令で「÷ 0」が実行された． \\
    13& 特権違反    & 不適切な実行モードで特権命令が実行された． \\
    14& 未定義命令  & {\tac}の機械語として解釈できない命令を実行した． \\
    15& SVC         & SVC 機械語命令が実行された． \\
  \end{tabular}
\end{mytable}

%-----------------------------------------
\section{メモリマップとI/Oマップ}
メモリ空間とI/O空間は8ビット毎にアドレス付けされている．
メモリは8ビットデータ，16ビットデータのどちらも読み書きできる．
I/Oは16ビットデータの読み書きしかできない．
メモリの場合は機械語命令のアドレッシング・モードによって，
8ビットデータと16ビットデータの区別をする．
16ビットデータは偶数アドレスを指定してアクセスしなければならない．

\subsection{メモリ空間}
\figref{tacMap}の「メモリマップ」に{\tac}のメモリマップを示す．
{\tac}のメモリ空間は\|0000h|から\|FFFFh|の64KiBである．
16ビットデータは偶数アドレスからの2バイトに配置され，
偶数アドレスを指定してアクセスする．
8ビットデータにアクセスするには，
Byte Register Indirect モードを用いる．
その他のアドレッシング・モードは，
16ビットデータをアクセスするために用いる．

リセット時に，\|E000h|から\|FFFFh|にIPL（ROM）が配置される．
{\tac}モードでは，IPLはマイクロSDからOSを読み出して起動する．
その他のモードでは，IPLが{\tec}の通信を中継する等の機能を果たす．
IPLはOSを読みだしたらIPL（ROM）を切り離しメモリ空間全体をRAMにした後，
OSに制御を渡す．
IPL（ROM）が切り離された後，
\|FFE0h|から\|FFFFh|は割込みベクタ領域になる．
16種類の割込み・例外ハンドラの入口番地をOSがセットする．

\subsection{I/O空間}
\figref{tacMap}の「I/Oマップ」に{\tac}のI/Oマップを示す．
{\tac}のI/O空間は\|00h|から\|FFh|の128ワードである．
I/O空間のアドレス幅は8ビットだが，
IN，OUT機械語命令ではI/Oアドレスが16ビットで表現される．
I/Oアドレスの上位8ビットは\|00h|になるようにする．
上位8ビットが\|00h|以外になった場合の動作は保証されない．
メモリ空間と異なり16ビットデータの読み書きしかできない．

%-----------------------------------------
\section{MMU（Memory Management Unit）}
ページング方式のMMUが使用できる．
MMUが働くのはユーザモードで実行中だけである．
MMUの制御は
\figref{tacMap}の「I/Oマップ」に示すポートをIN，OUT機械語命令で操作して行う．
以下では，MMUに関係のあるポートについて説明する．

\begin{center}
  \small\begin{tabular}{| r | c | c || c | c |}\hline
    \multirow{2}{*}{番地}
    & \multicolumn{2}{c||}{IN}
    & \multicolumn{2}{c|}{OUT}
    \\\cline{2-5}
         & 上位バイト & 下位バイト & 上位バイト & 下位バイト
    \\\hline\hline
    80h  & 00 & TLB[0]上位8bit & - & TLB[0]上位8bit \\\hline
    82h  & \multicolumn{2}{c||}{TLB[0]下位16bit}
         & \multicolumn{2}{c|}{TLB[0]下位16bit} \\\hline
    84h  & 00 & TLB[1]上位8bit & - & TLB[1]上位8bit \\\hline
    86h  & \multicolumn{2}{c||}{TLB[1]下位16bit}
         & \multicolumn{2}{c|}{TLB[1]下位16bit} \\\hline
    ...  & \multicolumn{2}{c||}{...}
         & \multicolumn{2}{c|}{...}   \\\hline
    9Ch  & 00 & TLB[7]上位8bit & - & TLB[7]上位8bit \\\hline
    9Eh  & \multicolumn{2}{c||}{TLB[7]下位16bit}
         & \multicolumn{2}{c|}{TLB[7]下位16bit} \\\hline
    A0h  &  00 & 00
         &  -  & IPL切離し \\\hline
    A2h  &  \multicolumn{2}{c||}{違反アドレス}
         &  -  & MMU有効化 \\\hline
    A4h  &  00 & 違反原因
         &  -  & - \\\hline
    A6h  &  00 & ページ番号
         &  -  & - \\\hline
  \end{tabular}
\end{center}

\subsection{違反アドレス}
  メモリ保護違反が発生した時，原因となった論理アドレスが記録される．

\subsection{違反原因（\texttt{0000 00BV}）}
  メモリ保護違反が発生した時，
  奇数アドレスを用いたワードアクセス（Bad Address）の場合
  \texttt{B}ビットが`1'になる．
  ページの保護モード違反（Memory Violation）の場合
  \texttt{V}ビットが`1'になる．
  これらのビットはCPUがIN命令でA4h番地を読むとクリアされる．

\subsection{ページ番号}
  ページ番号がTLBでヒットしなかった場合「TLB ミス例外」が発生する．
  その際，例外の原因となったページ番号が記録される．

\subsection{IPL切離し（\texttt{0000 000I}）}
  \texttt{I}に`1'を書き込むと，
  物理メモリ空間最後の8KiBに配置されたIPL（ROM）が切り離されRAMに置き換わる．
  これによりメモリ空間64KiB全てがRAMになる．
  通常，切り離しの操作はIPL自身がOSをロードした後で自動的に行う．
  IPL（ROM）がマップされている時でもコンソールからはRAMが見えるので，
  IPLを最後まで実行していない場合は注意が必要である．

\subsection{MMU有効化（\texttt{0000 000E}）}
  \texttt{E}に`1'を書き込むとMMUが有効になる．
  MMUが有効になるとCPUの実行モードが「I/O特権モード」，「ユーザモード」の時，
  ページからフレームへの変換（$p \to f$変換）が行われる．

\subsection{TLB（\texttt{TLB[0]〜TLB[7]）}}
  TLBはページ番号で検索されフレーム番号を出力し$p \to f$変換を行う．
  8エントリのTLBをIN，OUT機械語命令で参照・操作することができる．
  8つのTLBエントリはI/O空間の80h番地から9Eh番地までの範囲に配置される．
  1つのTLBエントリは24bitであるので，
  上位8bitと下位16bitに分けてアクセスする．
  以下ではTLBエントリの各ビット（フィールド）の意味を説明する．

  \begin{center}
  \small\begin{tabular}{| c || c |c|c|c|c|c|c| c |}\hline
    \multicolumn{9}{|c|}{TLBエントリの構成} \\\hline
    I/Oポート   &上位8bit&\multicolumn{7}{c|}{下位16bit} \\\hline
    ビット番号  &23 - 16&15&14&13&12&11&10-8&7 - 0      \\\hline
    ビットの意味& ページ番号&
    \|V|&\|U|&\|U|&\|R|&\|D|&\|RWX|&フレーム番号\\\hline
  \end{tabular}
  \end{center}

\subsubsection{ページ番号(\texttt{p})} 
エントリが管理するページの番号を設定する．
TLBエントリをページ番号で検索し，
該当ページを管理するエントリが見つからない場合，「TLB ミス例外」が発生する．

\subsubsection{\texttt{V}(Valid)}
エントリが有効かどうかを表す．
TLBを検索する際，$V=0$のエントリーは無視される．

\subsubsection{\texttt{U}(Undefined)}
ハードウェアでは使用してないビットである．
1ビットの記憶装置としてOSが自由に使用できる．

\subsubsection{\texttt{R}(Reference)}
OSがクリアしたあとユーザプログラムがページを参照すると`1'になる．
OSがページの参照に関する統計情報を取得するために使用する．

\subsubsection{\texttt{D}(Dirty)}
OSがクリアしたあとユーザプログラムがページに書き込みを行うと`1'になる．
OSがページをスワップアウトする必要があるか判断するために使用する．

\subsubsection{\texttt{RWX}(Read/Write/eXecute)}
ページの保護モードを3ビットの組み合わせで表現する．
機械語セグメントには\texttt{101}，
データセグメントやスタックセグメントには\texttt{110}，
読み出し専用のデータセグメントには\texttt{100}をセットする．
CPUが保護モードで許可されない種類のアクセスを行った場合，
「メモリ保護違反例外」が発生する．

\subsubsection{フレーム番号(\texttt{f})}
ページ番号に対応するフレーム番号を設定する．
MMUはページ番号がヒットしたエントリのフレーム番号を変換結果として出力する．

%-----------------------------------------
\section{IPLプログラム}
\label{ipl}
{\tac}はリセットされると自動的にIPLプログラム\footnote{
IPLのソースコードは
\url{https://github.com/tctsigemura/TeC7/tree/master/TaC/Ipl}
に公開されている．
}の実行を開始する．
IPLの第一の役割は，マイクロSDからOSを読出し起動することである．
しかし，{\tecS}の動作モード（\ref{tec7mode}参照）によっては，
{\tec}の補助（\ref{tec7assist}参照）を行う．
以下では動作モード毎にIPLの役割を説明する．

\subsection{{\tec}モード}
USBシリアル変換IC（FT232RL）から受信したデータを{\tec}のSIOへ送信する．
また，{\tec}のSIOから受信したデータをFT232RLに送信する．
FT232RLはPCとUSBシリアル接続が確立していればデータをPCに送るが，
確立していない場合はデータを無視する．
このようにして，{\tec}のシリアル通信をUSBを経由してPCに中継する．

Bluetoothモジュール（RN4020）は
シリアル通信でデータだけでなくコマンドも受け付ける．
Bluetooth接続が確立さていない状態で{\tac}がRN4020に何か送信すると，
コマンドとして解釈され不具合が生じる可能性がある．
そこで，Bluetooth接続が確立されている場合だけ{\tec}の通信を中継する．
このようにして{\tec}が知らない間に，{\tec}のシリアル通信先が切り換わる．

USBシリアルまたはBluetoothを通してPCから受信したデータに
``\|\033TWRITE\r\n|''の文字列を見つけると，
TWRITEプログラムの通信だと判断する．
TWRITEプログラムが送ってきた{\tec}の機械語プログラムを受信し，
{\tec}のコンソールを操作して{\tec}のメモリに書き込む．

なお，SETAボタンが押された状態で{\tec7}がリセットされた場合は，
OS（``\|kernel.bin|''）を読み込み制御をOSに移す．
この場合は，コンソールから{\tec}が操作できるが，
裏で{\tac}がOSを起動した状態になる．
{\tac}のOS上で{\tec}のプログラムを開発する場合等に使用することを想定している．

\subsection{{\tac}モード}
マイクロSDスロットを確認し，カードが挿入されていればOSを読み込んで起動する．
OSは，マイクロSDカードのFAT16ファイルシステムの
``\|\kernel.bin|''\footnote{
\texttt{.bin}ファイル形式については，「\texttt{Util--}解説書」
（\url{https://github.com/tctsigemura/Util--/raw/master/doc/umm.pdf}）の
付録B「ファイルフォーマット」を参照のこと．
}ファイルに格納されている．
IPLはOSに制御を移す前に，
自身が格納されたROM（\texttt{E000h - FFFFh}）を切り離しRAMに切り換える．

なお，リセット時にSETAボタンが押されていた場合は，
``\|\kernel.bin|''ファイルの代わりに
``\|\kernel0.bin|''ファイルからOSを読み込む．
カーネルのデバッグ中でも簡単にOSを起動できる．

\subsection{DEMOモード}
「DEMO1モード」，「DEMO2モード」では，
IPLがRN4020とFT232RLの通信を中継する．
USBシリアルで接続したPCから，RN4020の初期設定を行うことができる．
工場出荷時にRN4020のシリアル通信は115,200ボーに設定されているが，
FT232RLのデフォルトは9,600ボーである．
{\tac}がボーレート変換器の役割を果たす．
なお，FT232RL及びRN4020のボーレートは変更してはならない．

\subsection{RESET}
RN4020を工場出荷時の状態に戻す．
通常はシリアル通信でコマンドを送ることでRN4020を初期化できる．
しかし，
間違ってボーレートを変更したり，
ハードウェアフロー制御を有効にしたりすると，
コマンドを送ることができなくなる．
そのような場合に，この機能を使用する．

RN4020は，
電源投入後5秒以内に\texttt{WAKE\_HW}ピンを３回以上フリップすることで，
工場出荷時の状態に戻る．
ジャンパーをRESETの設定にして{\tecS}に電源を投入すると，
{\tac}がこの操作を行う．

